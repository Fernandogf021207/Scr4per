BEGIN;


CREATE TABLE IF NOT EXISTS casos.acciones
(
    idacciones bigserial NOT NULL,
    idusuario bigint,
    idcaso bigint,
    accion text COLLATE pg_catalog."default",
    fecha timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT acciones_pkey PRIMARY KEY (idacciones)
);

CREATE TABLE IF NOT EXISTS casos.casos
(
    idcaso bigserial NOT NULL,
    nombre text COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default" NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now(),
    fecha_ultima_modificacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    idusuario bigint NOT NULL,
    iddepartamento bigint NOT NULL,
    estado text COLLATE pg_catalog."default" NOT NULL DEFAULT 'activo'::text,
    CONSTRAINT casos_pkey PRIMARY KEY (idcaso)
);

CREATE TABLE IF NOT EXISTS casos.compartir
(
    idcompartir bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    idcaso bigint NOT NULL,
    idorganizacion_destino bigint,
    idarea_destino bigint,
    iddepartamento_destino bigint,
    estado text COLLATE pg_catalog."default" NOT NULL,
    id_solicitante bigint NOT NULL,
    id_aprobador bigint,
    fecha_solicitud timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    fecha_respuesta timestamp without time zone,
    CONSTRAINT compartir_pkey PRIMARY KEY (idcompartir)
);

CREATE TABLE IF NOT EXISTS entidades.actividad
(
    id_actividad serial NOT NULL,
    entidad character varying(50) COLLATE pg_catalog."default" NOT NULL,
    accion character varying(50) COLLATE pg_catalog."default" NOT NULL,
    id_usuario integer,
    nombre_usuario character varying(150) COLLATE pg_catalog."default" NOT NULL,
    fecha timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_autor integer,
    nombre_autor character varying(150) COLLATE pg_catalog."default",
    id_organizacion integer,
    detalles text COLLATE pg_catalog."default",
    CONSTRAINT actividad_pkey PRIMARY KEY (id_actividad)
);

CREATE TABLE IF NOT EXISTS entidades.actividad_sospechosa
(
    id_reporte serial NOT NULL,
    id_usuario integer,
    fecha timestamp without time zone DEFAULT now(),
    ip_usuario character varying(45) COLLATE pg_catalog."default",
    descripcion text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT actividad_sospechosa_pkey PRIMARY KEY (id_reporte)
);

CREATE TABLE IF NOT EXISTS entidades.area
(
    id_area integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nombre_area character varying(100) COLLATE pg_catalog."default" NOT NULL,
    id_organizacion integer NOT NULL,
    CONSTRAINT "PK_area" PRIMARY KEY (id_area)
);

CREATE TABLE IF NOT EXISTS entidades.departamento
(
    id_departamento integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nombre_departamento character varying(100) COLLATE pg_catalog."default" NOT NULL,
    id_area integer NOT NULL,
    id_organizacion integer NOT NULL,
    CONSTRAINT "PK_departamento" PRIMARY KEY (id_departamento)
);

CREATE TABLE IF NOT EXISTS entidades.ingresos
(
    id_ingreso integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    id_usuario integer NOT NULL,
    nombre character varying(50) COLLATE pg_catalog."default" NOT NULL,
    apellido_paterno character varying(50) COLLATE pg_catalog."default" NOT NULL,
    apellido_materno character varying(50) COLLATE pg_catalog."default",
    hora timestamp with time zone NOT NULL,
    tipo character varying(20) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_ingresos" PRIMARY KEY (id_ingreso)
);

CREATE TABLE IF NOT EXISTS entidades.intentos_recuperacion
(
    id serial NOT NULL,
    id_usuario integer,
    ip_usuario character varying(45) COLLATE pg_catalog."default",
    fecha timestamp without time zone DEFAULT now(),
    CONSTRAINT intentos_recuperacion_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS entidades.organizacion
(
    id_organizacion integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nombre_organizacion character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_organizacion" PRIMARY KEY (id_organizacion)
);

CREATE TABLE IF NOT EXISTS entidades.recuperacion_contrasenia
(
    id_recuperacion integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    id_usuario integer NOT NULL,
    token text COLLATE pg_catalog."default" NOT NULL,
    fecha_expiracion timestamp without time zone NOT NULL,
    CONSTRAINT recuperacion_contrasenia_pkey PRIMARY KEY (id_recuperacion)
);

CREATE TABLE IF NOT EXISTS entidades.tokens_invalidos
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    token text COLLATE pg_catalog."default" NOT NULL,
    fecha_expiracion timestamp with time zone NOT NULL,
    CONSTRAINT "PK_tokens_invalidos" PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS entidades.usuarios
(
    id_usuario integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nombre character varying(50) COLLATE pg_catalog."default" NOT NULL,
    apellidopaterno character varying(50) COLLATE pg_catalog."default" NOT NULL,
    apellidomaterno character varying(50) COLLATE pg_catalog."default",
    correo character varying(100) COLLATE pg_catalog."default" NOT NULL,
    telefono character varying(20) COLLATE pg_catalog."default",
    "contrase√±a" text COLLATE pg_catalog."default" NOT NULL,
    nivel integer,
    rol character varying(50) COLLATE pg_catalog."default",
    id_organizacion integer,
    id_area integer,
    id_departamento integer,
    debe_cambiar_contrasena boolean NOT NULL DEFAULT false,
    CONSTRAINT "PK_usuarios" PRIMARY KEY (id_usuario)
);

CREATE TABLE IF NOT EXISTS red_facebook.comments
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    commenter_profile_id bigint NOT NULL,
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT uq_comments_fb UNIQUE (post_id, commenter_profile_id)
);

CREATE TABLE IF NOT EXISTS red_facebook.graph_sessions
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    owner_username text COLLATE pg_catalog."default" NOT NULL,
    elements jsonb NOT NULL,
    style jsonb,
    layout jsonb,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    elements_path text COLLATE pg_catalog."default",
    CONSTRAINT graph_sessions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_graph_sessions_fb UNIQUE (owner_username)
);

CREATE TABLE IF NOT EXISTS red_facebook.posts
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'facebook'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    post_url text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT posts_pkey PRIMARY KEY (id),
    CONSTRAINT uq_posts_fb UNIQUE (platform, post_url)
);

CREATE TABLE IF NOT EXISTS red_facebook.profiles
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'facebook'::core.platform_enum,
    username text COLLATE pg_catalog."default" NOT NULL,
    full_name text COLLATE pg_catalog."default",
    profile_url text COLLATE pg_catalog."default",
    photo_url text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT uq_profiles_fb UNIQUE (platform, username)
);

CREATE TABLE IF NOT EXISTS red_facebook.reactions
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    reactor_profile_id bigint NOT NULL,
    reaction_type text COLLATE pg_catalog."default",
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT reactions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_rx_fb UNIQUE (post_id, reactor_profile_id)
);

CREATE TABLE IF NOT EXISTS red_facebook.relationships
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'facebook'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    related_profile_id bigint NOT NULL,
    rel_type core.rel_type_enum NOT NULL,
    collected_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT relationships_pkey PRIMARY KEY (id),
    CONSTRAINT uq_relationship_fb UNIQUE (platform, owner_profile_id, related_profile_id, rel_type)
);

CREATE TABLE IF NOT EXISTS red_instagram.comments
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    commenter_profile_id bigint NOT NULL,
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT uq_comments_ig UNIQUE (post_id, commenter_profile_id)
);

CREATE TABLE IF NOT EXISTS red_instagram.graph_sessions
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    owner_username text COLLATE pg_catalog."default" NOT NULL,
    elements jsonb NOT NULL,
    style jsonb,
    layout jsonb,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    elements_path text COLLATE pg_catalog."default",
    CONSTRAINT graph_sessions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_graph_sessions_ig UNIQUE (owner_username)
);

CREATE TABLE IF NOT EXISTS red_instagram.posts
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'instagram'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    post_url text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT posts_pkey PRIMARY KEY (id),
    CONSTRAINT uq_posts_ig UNIQUE (platform, post_url)
);

CREATE TABLE IF NOT EXISTS red_instagram.profiles
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'instagram'::core.platform_enum,
    username text COLLATE pg_catalog."default" NOT NULL,
    full_name text COLLATE pg_catalog."default",
    profile_url text COLLATE pg_catalog."default",
    photo_url text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT uq_profiles_ig UNIQUE (platform, username)
);

CREATE TABLE IF NOT EXISTS red_instagram.reactions
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    reactor_profile_id bigint NOT NULL,
    reaction_type text COLLATE pg_catalog."default",
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT reactions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_rx_ig UNIQUE (post_id, reactor_profile_id)
);

CREATE TABLE IF NOT EXISTS red_instagram.relationships
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'instagram'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    related_profile_id bigint NOT NULL,
    rel_type core.rel_type_enum NOT NULL,
    collected_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT relationships_pkey PRIMARY KEY (id),
    CONSTRAINT uq_relationship_ig UNIQUE (platform, owner_profile_id, related_profile_id, rel_type)
);

CREATE TABLE IF NOT EXISTS red_x.comments
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    commenter_profile_id bigint NOT NULL,
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT uq_comments_x UNIQUE (post_id, commenter_profile_id)
);

CREATE TABLE IF NOT EXISTS red_x.graph_sessions
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    owner_username text COLLATE pg_catalog."default" NOT NULL,
    elements jsonb NOT NULL,
    style jsonb,
    layout jsonb,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    elements_path text COLLATE pg_catalog."default",
    CONSTRAINT graph_sessions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_graph_sessions_x UNIQUE (owner_username)
);

CREATE TABLE IF NOT EXISTS red_x.posts
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'x'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    post_url text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT posts_pkey PRIMARY KEY (id),
    CONSTRAINT uq_posts_x UNIQUE (platform, post_url)
);

CREATE TABLE IF NOT EXISTS red_x.profiles
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'x'::core.platform_enum,
    username text COLLATE pg_catalog."default" NOT NULL,
    full_name text COLLATE pg_catalog."default",
    profile_url text COLLATE pg_catalog."default",
    photo_url text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT uq_profiles_x UNIQUE (platform, username)
);

CREATE TABLE IF NOT EXISTS red_x.reactions
(
    id bigserial NOT NULL,
    post_id bigint NOT NULL,
    reactor_profile_id bigint NOT NULL,
    reaction_type text COLLATE pg_catalog."default",
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT reactions_pkey PRIMARY KEY (id),
    CONSTRAINT uq_rx_x UNIQUE (post_id, reactor_profile_id)
);

CREATE TABLE IF NOT EXISTS red_x.relationships
(
    id bigserial NOT NULL,
    platform core.platform_enum NOT NULL DEFAULT 'x'::core.platform_enum,
    owner_profile_id bigint NOT NULL,
    related_profile_id bigint NOT NULL,
    rel_type core.rel_type_enum NOT NULL,
    collected_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT relationships_pkey PRIMARY KEY (id),
    CONSTRAINT uq_relationship_x UNIQUE (platform, owner_profile_id, related_profile_id, rel_type)
);

CREATE TABLE IF NOT EXISTS sabanas.archivos
(
    id_sabanas bigserial NOT NULL,
    ruta text COLLATE pg_catalog."default",
    ruta_analisis text COLLATE pg_catalog."default",
    estado character varying(20) COLLATE pg_catalog."default",
    hash_ruta text COLLATE pg_catalog."default",
    hash_ruta_analisis text COLLATE pg_catalog."default",
    id_numero_telefonico bigint,
    fecha_inicio time without time zone,
    fecha_termino time without time zone,
    compania character varying(25) COLLATE pg_catalog."default",
    id_compania_telefonica integer,
    CONSTRAINT archivos_pkey PRIMARY KEY (id_sabanas)
);

CREATE TABLE IF NOT EXISTS sabanas.compania_telefonica
(
    id_compania_telefonica serial NOT NULL,
    compania character varying(25) COLLATE pg_catalog."default",
    CONSTRAINT compania_telefonica_pkey PRIMARY KEY (id_compania_telefonica)
);

CREATE TABLE IF NOT EXISTS sabanas.ctg_antenas_telefonicas
(
    id_antena_telefonica bigserial NOT NULL,
    id_compania_telefonia integer,
    latitud_decimal double precision,
    longitud_decimal double precision,
    cell_id character(1) COLLATE pg_catalog."default",
    id_direccion bigint,
    altitud double precision,
    CONSTRAINT ctg_antenas_telefonicas_pkey PRIMARY KEY (id_antena_telefonica)
);

CREATE TABLE IF NOT EXISTS sabanas.ctg_direcciones
(
    id_direccion bigserial NOT NULL,
    calle text COLLATE pg_catalog."default",
    interior text COLLATE pg_catalog."default",
    exterior text COLLATE pg_catalog."default",
    colonia text COLLATE pg_catalog."default",
    municipio text COLLATE pg_catalog."default",
    ciudad text COLLATE pg_catalog."default",
    estado text COLLATE pg_catalog."default",
    pais text COLLATE pg_catalog."default",
    cp text COLLATE pg_catalog."default",
    direccion_completa text COLLATE pg_catalog."default",
    CONSTRAINT ctg_direcciones_pkey PRIMARY KEY (id_direccion)
);

CREATE TABLE IF NOT EXISTS sabanas.ctg_tipo_registro_sabana
(
    id_tipo_registro integer NOT NULL,
    tipo character(30) COLLATE pg_catalog."default",
    CONSTRAINT ctg_tipo_registro_sabana_pkey PRIMARY KEY (id_tipo_registro)
);

CREATE TABLE IF NOT EXISTS sabanas.imeis
(
    imeis_idimei bigserial NOT NULL,
    imei character(22) COLLATE pg_catalog."default",
    serie character(30) COLLATE pg_catalog."default",
    modelo_equipo text COLLATE pg_catalog."default",
    CONSTRAINT imeis_pkey PRIMARY KEY (imeis_idimei)
);

CREATE TABLE IF NOT EXISTS sabanas.imeis_archivos
(
    imeis_imeis_idimei bigint NOT NULL,
    archivos_id_sabanas bigint NOT NULL,
    CONSTRAINT imeis_archivos_pkey PRIMARY KEY (imeis_imeis_idimei, archivos_id_sabanas)
);

CREATE TABLE IF NOT EXISTS sabanas.imsis
(
    id_imsi bigserial NOT NULL,
    imsi text COLLATE pg_catalog."default",
    CONSTRAINT imsis_pkey PRIMARY KEY (id_imsi)
);

CREATE TABLE IF NOT EXISTS sabanas.imsis_archivos
(
    id_imsi bigint NOT NULL,
    archivos_id_sabanas bigint NOT NULL,
    CONSTRAINT imsis_archivos_pkey PRIMARY KEY (id_imsi, archivos_id_sabanas)
);

CREATE TABLE IF NOT EXISTS sabanas.numeros_telefonicos
(
    id_numero_telefonico bigserial NOT NULL,
    numero_telefonico character varying(12) COLLATE pg_catalog."default",
    codigo_area character varying(5) COLLATE pg_catalog."default",
    CONSTRAINT numeros_telefonicos_pkey PRIMARY KEY (id_numero_telefonico)
);

CREATE TABLE IF NOT EXISTS sabanas.numeros_telefonicos_casos
(
    numeros_telefonicos_id_numero_telefonico bigserial NOT NULL,
    casos_idcaso bigserial NOT NULL
);

CREATE TABLE IF NOT EXISTS sabanas.personas
(
    id_personas bigserial NOT NULL,
    nombre text COLLATE pg_catalog."default",
    paterno text COLLATE pg_catalog."default",
    materno text COLLATE pg_catalog."default",
    tipo integer,
    rfc character(10) COLLATE pg_catalog."default",
    curp character(22) COLLATE pg_catalog."default",
    identificador text COLLATE pg_catalog."default",
    CONSTRAINT personas_pkey PRIMARY KEY (id_personas)
);

CREATE TABLE IF NOT EXISTS sabanas.registros_telefonicos
(
    id_registro_telefonico bigserial NOT NULL,
    id_sabanas bigint,
    numero_a text COLLATE pg_catalog."default",
    numero_b text COLLATE pg_catalog."default",
    id_tipo_registro integer,
    fecha_hora timestamp without time zone,
    duracion integer,
    latitud character(40) COLLATE pg_catalog."default",
    longitud character(40) COLLATE pg_catalog."default",
    azimuth double precision,
    latitud_decimal double precision,
    longitud_decimal double precision,
    altitud double precision,
    coordenada_objetivo boolean,
    imei text COLLATE pg_catalog."default",
    telefono character(14) COLLATE pg_catalog."default",
    CONSTRAINT registros_telefonicos_pkey PRIMARY KEY (id_registro_telefonico)
);

CREATE TABLE IF NOT EXISTS sabanas.usuarios_lineas
(
    id_numero_telefonico bigint NOT NULL,
    id_sabanas bigint NOT NULL,
    id_personas bigint NOT NULL,
    id_direccion bigint NOT NULL,
    CONSTRAINT usuarios_lineas_pkey PRIMARY KEY (id_numero_telefonico, id_sabanas, id_personas, id_direccion)
);

ALTER TABLE IF EXISTS casos.acciones
    ADD CONSTRAINT acciones_idcaso_fkey FOREIGN KEY (idcaso)
    REFERENCES casos.casos (idcaso) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS casos.acciones
    ADD CONSTRAINT acciones_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS casos.casos
    ADD CONSTRAINT fk_casos_departamento FOREIGN KEY (iddepartamento)
    REFERENCES entidades.departamento (id_departamento) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.casos
    ADD CONSTRAINT fk_casos_usuario FOREIGN KEY (idusuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_aprobador FOREIGN KEY (id_aprobador)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_area FOREIGN KEY (idarea_destino)
    REFERENCES entidades.area (id_area) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_caso FOREIGN KEY (idcaso)
    REFERENCES casos.casos (idcaso) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_departamento FOREIGN KEY (iddepartamento_destino)
    REFERENCES entidades.departamento (id_departamento) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_organizacion FOREIGN KEY (idorganizacion_destino)
    REFERENCES entidades.organizacion (id_organizacion) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS casos.compartir
    ADD CONSTRAINT fk_compartir_solicitante FOREIGN KEY (id_solicitante)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS entidades.actividad
    ADD CONSTRAINT fk_actividad_autor_2 FOREIGN KEY (id_autor)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS entidades.actividad
    ADD CONSTRAINT fk_actividad_organizacion FOREIGN KEY (id_organizacion)
    REFERENCES entidades.organizacion (id_organizacion) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS entidades.actividad_sospechosa
    ADD CONSTRAINT actividad_sospechosa_id_usuario_fkey FOREIGN KEY (id_usuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS entidades.area
    ADD CONSTRAINT "FK_area_organizacion_id_organizacion" FOREIGN KEY (id_organizacion)
    REFERENCES entidades.organizacion (id_organizacion) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_area_id_organizacion"
    ON entidades.area(id_organizacion);


ALTER TABLE IF EXISTS entidades.departamento
    ADD CONSTRAINT "FK_departamento_area_id_area" FOREIGN KEY (id_area)
    REFERENCES entidades.area (id_area) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_departamento_id_area"
    ON entidades.departamento(id_area);


ALTER TABLE IF EXISTS entidades.departamento
    ADD CONSTRAINT "FK_departamento_organizacion_id_organizacion" FOREIGN KEY (id_organizacion)
    REFERENCES entidades.organizacion (id_organizacion) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_departamento_id_organizacion"
    ON entidades.departamento(id_organizacion);


ALTER TABLE IF EXISTS entidades.ingresos
    ADD CONSTRAINT "FK_ingresos_usuarios_id_usuario" FOREIGN KEY (id_usuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_ingresos_id_usuario"
    ON entidades.ingresos(id_usuario);


ALTER TABLE IF EXISTS entidades.intentos_recuperacion
    ADD CONSTRAINT intentos_recuperacion_id_usuario_fkey FOREIGN KEY (id_usuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS entidades.recuperacion_contrasenia
    ADD CONSTRAINT recuperacion_contrasenia_id_usuario_fkey FOREIGN KEY (id_usuario)
    REFERENCES entidades.usuarios (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS entidades.usuarios
    ADD CONSTRAINT "FK_usuarios_area_id_area" FOREIGN KEY (id_area)
    REFERENCES entidades.area (id_area) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS "IX_usuarios_id_area"
    ON entidades.usuarios(id_area);


ALTER TABLE IF EXISTS entidades.usuarios
    ADD CONSTRAINT "FK_usuarios_departamento_id_departamento" FOREIGN KEY (id_departamento)
    REFERENCES entidades.departamento (id_departamento) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS "IX_usuarios_id_departamento"
    ON entidades.usuarios(id_departamento);


ALTER TABLE IF EXISTS entidades.usuarios
    ADD CONSTRAINT "FK_usuarios_organizacion_id_organizacion" FOREIGN KEY (id_organizacion)
    REFERENCES entidades.organizacion (id_organizacion) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS "IX_usuarios_id_organizacion"
    ON entidades.usuarios(id_organizacion);


ALTER TABLE IF EXISTS red_facebook.comments
    ADD CONSTRAINT comments_commenter_profile_id_fkey FOREIGN KEY (commenter_profile_id)
    REFERENCES red_facebook.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_facebook.comments
    ADD CONSTRAINT comments_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_facebook.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_facebook.posts
    ADD CONSTRAINT posts_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_facebook.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_fb_posts_owner
    ON red_facebook.posts(owner_profile_id);


ALTER TABLE IF EXISTS red_facebook.reactions
    ADD CONSTRAINT reactions_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_facebook.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_facebook.reactions
    ADD CONSTRAINT reactions_reactor_profile_id_fkey FOREIGN KEY (reactor_profile_id)
    REFERENCES red_facebook.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_facebook.relationships
    ADD CONSTRAINT relationships_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_facebook.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_facebook.relationships
    ADD CONSTRAINT relationships_related_profile_id_fkey FOREIGN KEY (related_profile_id)
    REFERENCES red_facebook.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.comments
    ADD CONSTRAINT comments_commenter_profile_id_fkey FOREIGN KEY (commenter_profile_id)
    REFERENCES red_instagram.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.comments
    ADD CONSTRAINT comments_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_instagram.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.posts
    ADD CONSTRAINT posts_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_instagram.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_ig_posts_owner
    ON red_instagram.posts(owner_profile_id);


ALTER TABLE IF EXISTS red_instagram.reactions
    ADD CONSTRAINT reactions_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_instagram.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.reactions
    ADD CONSTRAINT reactions_reactor_profile_id_fkey FOREIGN KEY (reactor_profile_id)
    REFERENCES red_instagram.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.relationships
    ADD CONSTRAINT relationships_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_instagram.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_instagram.relationships
    ADD CONSTRAINT relationships_related_profile_id_fkey FOREIGN KEY (related_profile_id)
    REFERENCES red_instagram.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.comments
    ADD CONSTRAINT comments_commenter_profile_id_fkey FOREIGN KEY (commenter_profile_id)
    REFERENCES red_x.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.comments
    ADD CONSTRAINT comments_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_x.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.posts
    ADD CONSTRAINT posts_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_x.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_x_posts_owner
    ON red_x.posts(owner_profile_id);


ALTER TABLE IF EXISTS red_x.reactions
    ADD CONSTRAINT reactions_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES red_x.posts (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.reactions
    ADD CONSTRAINT reactions_reactor_profile_id_fkey FOREIGN KEY (reactor_profile_id)
    REFERENCES red_x.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.relationships
    ADD CONSTRAINT relationships_owner_profile_id_fkey FOREIGN KEY (owner_profile_id)
    REFERENCES red_x.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS red_x.relationships
    ADD CONSTRAINT relationships_related_profile_id_fkey FOREIGN KEY (related_profile_id)
    REFERENCES red_x.profiles (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;

END;